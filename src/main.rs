#![warn(clippy::pedantic)]
#![warn(clippy::nursery)]
#![warn(clippy::unwrap_used)]
#![warn(clippy::expect_used)]

use integer_sqrt::IntegerSquareRoot;

fn main() {
    println!("Problem 1: {}", problem_1(1000));
    println!("Problem 2: {}", problem_2(FOUR_MILLION));
    println!("Problem 3: {}", problem_3(600_851_475_143));
}

/*
 * If we list all the natural numbers below 10 that are multiples of 3 or 5,
 * we get 3, 5, 6 and 9. The sum of these multiples is 23.
 *
 * Find the sum of all the multiples of 3 or 5 below 1000.
 */
fn problem_1(limit: usize) -> usize {
    (1..limit)
        .filter(|n| n % 3 == 0 || n % 5 == 0)
        .sum()
}

/*
 * Each new term in the Fibonacci sequence is generated by adding the previous
 * two terms. By starting with 1 and 2, the first 10 terms will be:
 *
 *   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do 
 * not exceed four million, find the sum of the even-valued terms.
 */
// Rather amazingly, this works with the slow definition of `fib` and is
// still really fast! I suspect that's mostly because we get to 4 million
// quite quickly rather than the fact that Rust is particularly fast at
// running this code. I also suspect that this was supposed to force the
// the use of some kind of BigInt back in the day, but we don't need that
// here since u32 is sufficient to get us there.
const FOUR_MILLION: u32 = 4_000_000;

fn problem_2(limit: u32) -> u32 {
    // This slow recursive version is actually sufficient for this
    // task.
    // fn fib(n: u32) -> u32 {
    //     if n < 2 {
    //         n
    //     } else {
    //         fib(n-1) + fib(n-2)
    //     }
    // }

    fn fast_fib(n: u32) -> u32 {
        let mut a = 0;
        let mut b = 1;
        // Invariants:
        //   a = fib(i)
        //   b = fib(i+1)
        for _ in 0..n {
            (a, b) = (b, a+b);
        }
        a
    }

    // This shouldn't ever actually generate an infinite computation
    // since the `take_while` is guaranteed to eventually be true
    // and turn this into a finite computation.
    #[allow(clippy::maybe_infinite_iter)]
    (1..)
        .map(fast_fib)
        .take_while(|f| f < &limit)
        .filter(|n| n % 2 == 0)
        .sum()
}

/*
 * The prime factors of 13195 are 5, 7, 13 and 29.
 *
 * What is the largest prime factor of the number 600851475143 ?
 */
fn problem_3(target: usize) -> usize {
    // Unwrapping should be safe since `target.integer_sqrt()` should get us enough primes.
    #[allow(clippy::unwrap_used)]
    let factors = primal::Sieve::new(target.integer_sqrt())
        .factor(target)
        .unwrap();
    let (biggest_prime, _) = factors[factors.len()-1];
    biggest_prime
}

#[cfg(test)]
mod tests {
    use crate::{problem_1, problem_2, problem_3};

    #[test]
    fn problem_1_test() {
        assert_eq!(problem_1(10), 23);
    }

    #[test]
    fn problem_2_test() {
        assert_eq!(problem_2(200), 2+8+34+144);
    }

    #[test]
    fn problem_3_test() {
        assert_eq!(problem_3(13195), 29);
    }
}