#![warn(clippy::pedantic)]
#![warn(clippy::nursery)]
#![warn(clippy::unwrap_used)]
#![warn(clippy::expect_used)]

fn main() {
    println!("Problem 2: {}", problem_2(FOUR_MILLION));
}

/*
 * Problem 2: Even Fibonacci numbers
 * 
 * Each new term in the Fibonacci sequence is generated by adding the previous
 * two terms. By starting with 1 and 2, the first 10 terms will be:
 *
 *   1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do 
 * not exceed four million, find the sum of the even-valued terms.
 */
// Rather amazingly, this works with the slow definition of `fib` and is
// still really fast! I suspect that's mostly because we get to 4 million
// quite quickly rather than the fact that Rust is particularly fast at
// running this code. I also suspect that this was supposed to force the
// the use of some kind of BigInt back in the day, but we don't need that
// here since u32 is sufficient to get us there.
const FOUR_MILLION: u32 = 4_000_000;

fn problem_2(limit: u32) -> u32 {
    // This slow recursive version is actually sufficient for this
    // task.
    // fn fib(n: u32) -> u32 {
    //     if n < 2 {
    //         n
    //     } else {
    //         fib(n-1) + fib(n-2)
    //     }
    // }

    fn fast_fib(n: u32) -> u32 {
        let mut a = 0;
        let mut b = 1;
        // Invariants:
        //   a = fib(i)
        //   b = fib(i+1)
        for _ in 0..n {
            (a, b) = (b, a+b);
        }
        a
    }

    // This shouldn't ever actually generate an infinite computation
    // since the `take_while` is guaranteed to eventually be true
    // and turn this into a finite computation.
    #[allow(clippy::maybe_infinite_iter)]
    (1..)
        .map(fast_fib)
        .take_while(|f| f < &limit)
        .filter(|n| n % 2 == 0)
        .sum()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn problem_2_test() {
        assert_eq!(problem_2(200), 2+8+34+144);
    }
}